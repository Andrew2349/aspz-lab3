Практична робота №3  
Дослідження обмежень ресурсів у середовищі Linux/Docker

Студент: ТВ-31 Троцюк Андрій
Варіант:17  
ОС: Ubuntu (через WSL)

Мета роботи

Ознайомитися з механізмами обмеження ресурсів у Linux за допомогою `ulimit`, `shmget`, сигналів та інших засобів, які можна застосовувати у звичайному середовищі Linux або в Docker-контейнерах.  
Дослідити, як система реагує на перевищення встановлених обмежень та реалізувати відповідні обробки помилок.

Список виконаних завдань

Завдання 3.1  
Використав команду ulimit -a для перегляду поточних лімітів процесу. Також перевірено жорсткі (ulimit -H) та м’які (ulimit -S) обмеження.

Завдання 3.2  

Під час спроби використання утиліти perf у Docker-контейнері на базі Ubuntu 20.04 виникла помилка

Завдання 3.3  
Програма dice_throw.c нескінченно генерує числа (від 1 до 6) і записує у файл dice_results.txt. Перед запуском встановлено обмеження: ulimit -f 10. Після досягнення ліміту на розмір файлу (5 КБ) програма аварійно завершується з помилкою: Error: file size limit exceeded (signal 25)

Завдання 3.4  
Програма lottery.c безперервно генерує числа для лотереї. Перед запуском встановлено обмеження: ulimit -t 1. Це призвело до завершення програми системою після ~1 секунди процесорного часу

Завдання 3.5  
Створив програму copy.c, яка:перевіряє кількість аргументів, відкриває вхідний файл для читання,відкриває вихідний файл для запису, копіює вміст побайтно, обробляє помилки відкриття файлів та перевищення ліміту на розмір файлу. Перед запуском встановив обмеження ulimit -f 1024 і отримав Error: file size limit exceeded (signal 25)

Завдання 3.6  
stack_limit.c викликає саму себе та виводить глибину рекурсії. Після досягнення приблизно 50 рекурсивних викликів виникає помилка: Segmentation fault (core dumped)

Завдання 3.7 (індивідуальне, варіант 17)  
У програмі shm_example.c я продемонстрував використання спільної пам'яті через системні виклики shmget, shmat, shmdt і shmctl. Програма перевіряє ліміт для використання заблокованої пам'яті за допомогою getrlimit(RLIMIT_MEMLOCK), потім створює сегмент спільної пам'яті розміром 64 КБ за допомогою shmget. Після цього програма приєднується до цього сегменту через shmat, записує в нього рядок, зчитує його і виводить на екран. Наприкінці сегмент від’єднується через shmdt, і його видалення виконується за допомогою shmctl(IPC_RMID). За допомогою ulimit -l було встановлено ліміт на 65536 КБ (64 МБ), що дозволило успішно створити сегмент спільної пам'яті.


Висновок
У цій роботі я практично дослідив, як у Linux (і Docker-контейнерах) керувати ресурсами процесів за допомогою ulimit і API (сигнали, shmget),встановлював обмеження на розмір файлу, CPU-час, стек і заблоковану пам’ять та обробляв відповідні помилки та демонстрував створення й роботу з сегментом спільної пам’яті

Приклади запуску
Компіляція
gcc dice_throw.c -o dice_throw
gcc lottery.c -o lottery
gcc copy.c -o copy
gcc stack_limit.c -o stack_limit
gcc shm_example.c -o shm_example

Обмеження
ulimit -f 10      # 5 КБ файл
ulimit -t 1       # 1 секунда CPU
ulimit -s 64      # 64 КБ стек
ulimit -l         # показує обмеження на shared memory

Запуск
./dice_throw
./lottery
./copy source.bin dest.bin
./stack_limit
./shm_example
