Практична робота №3  

Дослідження обмежень ресурсів у середовищі Linux/Docker

Студент: ТВ-31 Троцюк Андрій

Варіант:17  

ОС: Ubuntu (через WSL)



Список виконаних завдань

Завдання 3.1
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:
![image](https://github.com/user-attachments/assets/53fb84cd-02c5-4d1c-9ecb-c7e1853f8f9a)

Результат:

![image](https://github.com/user-attachments/assets/070d74cc-527b-4608-8691-0a9f50ccb9fd)

![image](https://github.com/user-attachments/assets/0601d57e-17b1-4576-9499-53fc666617b8)

Використав команду ulimit -a для перегляду поточних лімітів процесу. Також перевірено жорсткі (ulimit -H) та м’які (ulimit -S) обмеження.

Завдання 3.2  

У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.

Результат:

![image](https://github.com/user-attachments/assets/72bffd0e-d57b-403c-b102-2b27e0cefe34)

Під час спроби використання утиліти perf у Docker-контейнері на базі Ubuntu 20.04 виникла помилка

Завдання 3.3  

Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

Результат:

![image](https://github.com/user-attachments/assets/bc6b70ae-ba62-4f35-85ed-d0eead2c0297)

![image](https://github.com/user-attachments/assets/e454713c-b42c-4d70-91c1-b5d756a0007a)

![image](https://github.com/user-attachments/assets/e868062d-8cbf-417f-951a-b743c0ab383f)


Програма dice_throw.c нескінченно генерує числа (від 1 до 6) і записує у файл dice_results.txt. Перед запуском встановлено обмеження: ulimit -f 10. Після досягнення ліміту на розмір файлу (5 КБ) програма аварійно завершується з помилкою: Error: file size limit exceeded (signal 25)

Завдання 3.4  

Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.

Результат:

![image](https://github.com/user-attachments/assets/c3a90ef9-f9f8-4316-928c-975edccf741c)

![image](https://github.com/user-attachments/assets/e868e9a8-063d-4bce-9d9a-61f35c62318a)

Команда ulimit -t 1 обмежує процес до 1 секунди процесорного часу. Після вичерпання цього часу надходить сигнал SIGXCPU (24) і процес завершується.
У моєму середовищі ulimit -t призводить до жорсткого «SIGKILL» без попередження й моїм обробникам навіть не дають шанс спрацювати. Тому я замінив зовнішню команду ulimit на вбудований в програму віртуальний таймер ITIMER_VIRTUAL, який рахує тільки CPU-час, і зловив сигнал SIGVTALRM.


Завдання 3.5  

Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.

![image](https://github.com/user-attachments/assets/8d018e11-b0b6-4ab7-ae19-c7f852859634)

Результат:

![image](https://github.com/user-attachments/assets/913ca02f-0638-4e0f-afee-1f38291f060f)
![image](https://github.com/user-attachments/assets/b8f14c8e-ffe5-4ded-9134-4c27af3bf0e6)


Я створив програму copy.c, яка перевіряє кількість аргументів, відкриває вхідний файл для читання,відкриває вихідний файл для запису, копіює вміст побайтно, обробляє помилки відкриття файлів та перевищення ліміту на розмір файлу. Перед запуском встановив обмеження ulimit -f 1024 і отримав Error: file size limit exceeded (signal 25)

Завдання 3.6 

Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

Результат:

![image](https://github.com/user-attachments/assets/e46d57e7-2461-4f0e-9b4b-a6d598958851)
![image](https://github.com/user-attachments/assets/19e3ce02-b5e8-4fdd-b984-51ddcec7364b)

Програма викликає саму себе та виводить глибину рекурсії. Після досягнення приблизно 50 рекурсивних викликів виникає помилка: Segmentation fault (core dumped)

Завдання 3.7 (індивідуальне, варіант 17)  

Написати програму, що використовує спільну пам’ять (shmget) та перевірити ulimit -l.

Результат:

![image](https://github.com/user-attachments/assets/28f3c083-c5e0-4c98-a50a-3035b6471f6e)
![image](https://github.com/user-attachments/assets/52fd833b-4f77-4ac5-9d72-2feaf63c076c)

У програмі shm_example.c я продемонстрував використання спільної пам'яті через системні виклики shmget, shmat, shmdt і shmctl. Програма перевіряє ліміт для використання заблокованої пам'яті за допомогою getrlimit(RLIMIT_MEMLOCK), потім створює сегмент спільної пам'яті розміром 64 КБ за допомогою shmget. Після цього програма приєднується до цього сегменту через shmat, записує в нього рядок, зчитує його і виводить на екран. Наприкінці сегмент від’єднується через shmdt, і його видалення виконується за допомогою shmctl(IPC_RMID). За допомогою ulimit -l я встановив ліміт на 65536 КБ (64 МБ), що дозволило успішно створити сегмент спільної пам'яті.


Висновок

У цій роботі я практично дослідив, як у Linux (і Docker-контейнерах) керувати ресурсами процесів за допомогою ulimit і API (сигнали, shmget),встановлював обмеження на розмір файлу, CPU-час, стек і заблоковану пам’ять та обробляв відповідні помилки та демонстрував створення й роботу з сегментом спільної пам’яті

